%!TEX root=../master.tex

%INTRO
% Information flow control
% Attached to code
% Formal
% Possible to do both static and run-time checking
% Uses labels and relabelling to control flow, subjects own objects and allow other subjects to access their objects

\newcommand{\policy}[2]{\ensuremath{#1\!:\;#2}}

\section{Decentralized Label Model}

\mads{\issue{41} Mere info, historie, brug, etc }

\newcommand{\xvalue}{value}
\newcommand{\xvalues}{values}
This section describes the Decentralized Label Model(DLM) both formally and informally with small examples.
\mikkelin{Jeg har svært ved at finde den uformelle beskrivelse i teksten.}

\subsection{Definition of terms}
\mikkelin{\#44 Acts-for skal flyttes til der hvor det bruges første gang (Limitations som det er nu)}
\mikkelin{\#44 Privacy policy skal flyttes til Labels}
This section defines and explains some of the terms used to explain the DLM.

\paragraph{Acts for relation}
The acts for relation, $\rightarrow$, can be used to model groups and roles.
To model two \principals{}, Amy and Bob, that act for a group of programmers: $Amy \rightarrow programmers$ and $Bob \rightarrow programmers$.
Or if Amy has different roles: $Amy \rightarrow Amy\_programmer$ and $Amy \rightarrow Amy\_admin$.
\mikkel{\#45 Vi mangler en beskrivelse af hvad formålet med acts for er (også bedre forklaring af eksemplerne) og hvad det betyder i DLM.}

\stefan{\#46 brug $\succeq$ i stedet for $\rightarrow$ }

This is also called a \principal{} hierarchy.
Formally we use the $\succeq$-operator when representing acts for.\footnote{$\succeq$ is reflexive and transitive and not anti-symmetric}
For instance $x \succeq y$ means $x$ acts for $y$.
A \principal{} hierarchy $P$ is a set of ordered pairs of \principvals{}.
So if we have $P \vdash x \succeq y$ it means that $(x,y) \in P$.

\paragraph{Privacy policy}
A privacy policy is represented as an owner of some \xvalue{} and a set of readers.
The syntax is: $\policy{\text{<\emph{owner}>}}{\text{<\emph{reader}>}}$.
The owner is the \principal{} who owns the \xvalue{} that was used for constructing the \xvalue{}.
The readers are the \principals{} allowed by the owner.
The owner is implicitly allowed to read his own data.
If we want a \principal{} $p$ that should not allow any other readers we use the following syntax: $\policy{p}{}$.

\subsection{Labels}\bruno{Måske lidt roddet afsnit?}
A \xvalue{} is associated with a label.
The label is a set of privacy policies.
When the \xvalue{} flows through the system, all the policies need to be obeyed.
This means that the effective set of \principals{} able to read the \xvalue{} is the intersection of all policies in a label.


Labeled \xvalues{} are only released by the consensus of all the owners and can only be read by the readers.
If one or several privacy policies are added to a label it restricts the access to the \xvalue{}.
A label with no policies  means that all readers are allowed.

If a \principal{} is not among the owners of a label, it is the same as if it was added as a privacy policy with all posible readers, implicitly indicating that this owner has no preference of who reads the \xvalue{}.

\begin{example}{Redundant owner}
In a system with owners $o_1, o_2, o_3$ and readers $r_1, r_2, r_3$, the following labels are defined:
$$L_1 = \{\policy{o_1}{r_1,r_2};\; \policy{o_2}{r_2, r_3}\}$$
$$L_2 = \{\policy{o_1}{r_1,r_2};\; \policy{o_2}{r_2, r_3};\; \policy{o_3}{r_1, r_2, r_3}\}$$
Since the policy of $o_3$ is to allow everyone to read it introduces no restriction to the label.
Therefore we say that the effective reader set of the two labels are equal.
\end{example}

When a label interprets its privacy policies it understands it as a set of flows.
A flow $(o,r)$ is a flow of information from owner $o$ to reader $r$.
If a label contains this flow it means that the owner allows the reader to read the \xvalue{}.
If we have three \principals{} $A$, $B$, $C$ and a label: $\{\policy{A}{B}; \ \policy{C}{}\}$.
This means that $A$ allows its \xvalue{} to be read by $B$, $B$ allows every reader and $C$ allows no readers.
Therefore the flow set of the label is: $\{(A,B), (B,A), (B,B), (B,C) \}$.
\stefan{\#47 Skal omskrives så det forklarer hvordan MAN skal fortolke en label, i stedet for hvordan en laber fortolker sig selv}
\stefan{\#47 Beskrivelse af hvad man skal bruges flows til}


A label can contain several privacy policies for the same \principal{}.
These are enforced just as other policies.

Some further notation:
We have policy $K$ and label $L$.
\begin{itemize}
\item $K \in L$, policy $K$ is a part of label $L$
\item $\textbf{o}(K)$ or $\textbf{o}K$, the owner of policy $K$
\item $\textbf{r}(K)$ or $\textbf{r}K$, the set of readers of policy $K$
\end{itemize}
\stefan{\#48 Omskriv til o(k) notation i hele afsnittet}
\mikkelin{\#49 Skal flyttes til starten af Labels (der hvor policies introduceres)}

\subsection{Rules}
This section contains the rules that need to be followed when manipulating labels to avoid information leakage.

\paragraph{Label join}
When deriving a \xvalue{} from two \xvalues{}, the derived \xvalue{}s label must reflect its sources, so it has to be at least as restrictive.
Thus the label assigned to the derived \xvalue{} is the union of the two source labels.
This gives us the following join rule:
\begin{definition}
  $L_1 \sqcup L_2 = L_1 \cup L_2$
  \mikkelin{\#50 Beskrivelse af $\sqcup$ / join}
\end{definition}


\paragraph{Relabeling by declassification}
\stefan{\issue{51} Intro og forklaring af hvad det skal bruges til}
The owners of the labels control their data, but sometimes policies are overly restrictive and one wants to relax them.

The authority is a set of \principals{} which is the authority of the process of declassification.
If a process has the authority of a \principal{}, the actions of the process are permitted.
This means that if a \principal{} is in the authority set this can be declassified.

A label $L_1$ can be relabeled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ where $L_A$ is the authority.
The authority is a label $L_A$ of the form $\{p: \ \}$ for every \principal{} in the current authority.

$L_1$ can be relabelled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ is true.
\begin{definition}
    $$\frac{L_1 \sqsubseteq L_2 \sqcup L_A}{L_1 \text{ may be declassified to } L_2}$$
\end{definition}

\paragraph{Relabeling by Restriction}
This rule is for when one is doing an assignment of a \xvalue{} into a variable.
When a \xvalue{} is read its label is relabelled to the variable and forgotten.
\mikkel{Hvad betyder det at en label er relabelled til en variabel?}
To avoid leakage the label of the variable must be at least as restrictive.
For instance if we have two labels, $L_1$ and $L_2$, $L_1 \sqsubseteq L_2$ means that $L_2$ is more restricted than $L_1$.

So a restriction is when the new label guarantees to enforce all of the policies from the old label.
If we have policy $J$ in $L_1$ it is guranteed by another policy $K$ if they have the same owner and $rK$ is a subset of $rJ$.
\begin{definition}
$$\frac{\forall (J \ \in \ L_1) \exists (K \ \in \ L_2)(oK = oJ \ \wedge \ rK \subseteq rJ)}{L_1 \sqsubseteq L_2}$$
\end{definition}
\bruno{definition of the relabeling rule - skal den være her?}

\subsection{Limitations}
The rule of restriction is too strict as it is only possible to remove readers and add policies \stefan{hvorfor er dette tilfældet?} and therefore prevents valid relabelings.
There are three possible valid relabelings which are not possible at the moment:
\mikkel{\#44 Acts for burde blive forklaret heromkring sådan at det passer med det emne det relaterer sig til.}
\begin{itemize}
\item Adding readers - if we have $r' \succeq r$ and $r$ is a reader of some owner, $'r$ should be too.
\item Replacing owners - if we have $o' \succeq o$ then it should be possible to replace $o$ with $o'$.
\item Self-authorization - every \principal{} that acts for an owner of a policy should be possible to add as a reader.
\end{itemize}

\subsubsection{Extending the relabeling by restriciton rule}
We need to extend the rule in order to be able to do the things discussed above.

To take the \principal{} hierarchy into account when interpreting a label an interpretation function $\textbf{X}$ is introduced.
For now\mikkel{Ændres det senere?} $\textbf{X}$ takes a label as argument and the set of \principals{} $P$ as an implicit argument.\mikkel{Hvad er et implicit argument?}
Informally this function makes sure that if a reader or owner that acts for some \principal{} $p$ - that $p$ is included in the label interpretation.
\mikkel{Jeg forstår ikke den her sidste sætning. Det er som om der mangler noget.}

The set of flows for a label need to satisfy two constraints for the given principal hierarchy.
One for readers and one for owners.
The following is the shows the reader constraint:
If we have $(o,r)$ and $r' \succeq r$ then $(o,r)'$ must also be in the set of flows.
Formally ($\rightarrow$ used for implication):
\begin{center}
  $r' \succeq r \ \wedge \ (o,r) \in \textbf{X}L \rightarrow (o,r') \in \textbf{X}L$
\end{center}
And the owner constraint:
If we have $(o,r)$ and $o' \succeq o$ and relabel to $(o',r)$, so a owner gets replaced by an owner that acts for it.
\begin{center}
  $o' \succeq o \ \wedge \ (o',r) \notin \textbf{X}L \rightarrow (o,r) \notin \textbf{X}L$
\end{center}

The function \textbf{R} is essentially adds all readers that can be found by looking at the acts for relations.
The \textbf{O} function converts a label into a set of flows and removes the ones that are not allowed.
Definition of the interpretation function $\textbf{X}$:
\begin{definition}
  $\textbf{X}L \ = \ \textbf{OR}L \ = \ \{(o,r)|\forall (I \in L) \textbf{o}I \succeq o \rightarrow [r \succeq \textbf{o}I \vee \exists (r' \in \textbf{r}I) r \succeq r'] \}$
\end{definition}

By using \textbf{X} we can verify a relabeling by applying the following correctness check.
\begin{definition}
  $\frac{\textbf{X}(L_1, P)\subseteq \textbf{X}(L_2,P)}{\text{Relabeling from } L_1 \text{ to } L_2 \text{ is safe in } P }$
\end{definition}
\mikkelin{Jeg synes alle definitionerne i ovenstående er for lidt forklarende.
Det er for lidt information man får når der kun er en ligning/et udtryk.}

\subsection{Channels}
The model contains two channels, an input and an output channel.
Information can be leaked through these channels, therefore they have a label associated to them.
When a \xvalue{} enters the system through an input channel, the \xvalue{} gets the label of the input channel.
If a \xvalue{} is written to an output channel it can only be done if the label of the output channel is at least as restrictive as the label of the \xvalue{}.
\bruno{Example?}
\mikkelin{Jeg synes vi skal lave et eksempel (fx noget pseudo kode) og så bruge det fra start til slut.}

\subsection{Static checking}
\bruno{Udvider correctnes check'et så det kan bruges til statisk check}
