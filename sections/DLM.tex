%!TEX root=../master.tex

\newcommand{\policy}[2]{\ensuremath{#1\!:\;#2}}

\section{Decentralized Label Model}
The Decentralized Label Model (DLM) is an information flow control model.\cite{myers1999mostly}
As the name suggests it revolves around labels (similar to previous security models), however, DLM is decentralized.
This means that it can be applied to systems with no trusted third party, or even any trust throughout the system.
By attaching security labels to objects in code it can be controlled how information should be shared throughout the code and at code-endpoints (input/output to/from other programs).
It is possible to do both static and run-time checking of labels.
The final major point of DLM is that it is formalized and even though no implementation is supplied, it should be applicable to other existing programming languages.

\newcommand{\xvalue}{value}
\newcommand{\xvalues}{values}
This section describes DLM with small examples.

\subsection{Labels}
A \xvalue{} is associated with a label.
The label is a set of privacy policies.
When the \xvalue{} flows through the system, all the policies need to be obeyed.
This means that the effective set of \principals{} able to read the \xvalue{} is the intersection of all policies in a label.

A privacy policy is represented as an owner of some \xvalue{} and a set of readers.
The syntax is: $\policy{\text{<\emph{owner}>}}{\text{<\emph{reader}>}}$.
The owner is the \principal{} who owns the \xvalue{} that was used for constructing the \xvalue{}.
The readers are the \principals{} allowed by the owner.
The owner is implicitly allowed to read his own data.
If we want a \principal{} $p$ that should not allow any other readers we use the following syntax: $\policy{p}{}$.

If we have policy $K$ and label $L$, we have following notation:
\begin{itemize}
\item $K \in L$, policy $K$ is a part of label $L$
\item $\textbf{o}(K)$, the owner of policy $K$
\item $\textbf{r}(K)$, the set of readers of policy $K$
\end{itemize}

Labeled \xvalues{} are only released by the consensus of all the owners and can only be read by the readers.
If one or several privacy policies are added to a label it restricts the access to the \xvalue{}.
A label with no policies  means that all readers are allowed.

If a \principal{} is not among the owners of a label, it is the same as if it was added as a privacy policy with all posible readers, implicitly indicating that this owner has no preference of who reads the \xvalue{}.

\begin{example}{Redundant owner}
In a system with owners $o_1, o_2, o_3$ and readers $r_1, r_2, r_3$, the following labels are defined:
$$L_1 = \{\policy{o_1}{r_1,r_2};\; \policy{o_2}{r_2, r_3}\}$$
$$L_2 = \{\policy{o_1}{r_1,r_2};\; \policy{o_2}{r_2, r_3};\; \policy{o_3}{r_1, r_2, r_3}\}$$
Since the policy of $o_3$ is to allow everyone to read it introduces no restriction to the label.
Therefore we say that the effective reader set of the two labels are equal.
\end{example}

When we want to perform relabelling (see later in this section), we need to ensure that the information flow remains unchanged, as a relabelling is only allowed if this is the case.
In order to ensure this we first need a way to interpret each label as a set of flows, so that we can determine whether a relabelling would change the information flow.
A flow $(o,r)$ is a flow of information from owner $o$ to reader $r$.
If a label contains this flow it means that the owner allows the reader to read the \xvalue{}.
If we have three \principals{} $A$, $B$, $C$ and a label: $\{\policy{A}{B}; \ \policy{C}{}\}$.
This means that $A$ allows its \xvalue{} to be read by $B$, $B$ allows every reader and $C$ allows no readers.
Therefore the flow set of the label is: $\{(A,B), (B,A), (B,B), (B,C) \}$.

A label can contain several privacy policies for the same \principal{}.
These are enforced just as other policies.

\subsection{Rules}
This section contains the rules that need to be followed when manipulating labels to avoid information leakage.

\paragraph{Label join}
When deriving a \xvalue{} from two \xvalues{}, the derived \xvalue{}s' label must reflect its sources, so it has to be at least as restrictive.
The relation $\sqsubseteq$ determines that a label is \textit{at least as restrictive}.
For two labels $L_1$ and $L_2$, if we have $L_1 \sqsubseteq L_2$, $L_1$ is at least as restrictive as $L_2$.
Then, in order to keep the restrictiveness of a combination of two labels, the resulting label for a derived \xvalue{} is the union of the two source labels.
This gives us the following join rule:
\begin{definition}
  $L_1 \sqcup L_2 = L_1 \cup L_2$
\end{definition}

The join rule will ensure that any joining of values will also result in a joining of labels, so that any combination of rules will be upheld.

\paragraph{Relabeling by declassification}
The owners of the labels control their data, but sometimes policies are overly restrictive and one wants to relax them.
This can be used to sanitize \xvalues{} whose security policies, in respect to one ore more owners, have changed throughout the run of a program.
This works in opposition to restricting rules, which is used to ensure information is not leaked, whereas this is enabling intended leaking (of sanitized information).

The authority is a set of \principals{} which is the authority of the process of declassification.
If a process has the authority of a \principal{}, the actions of the process are permitted.
This means that if a \principal{} is in the authority set this can be declassified.

A label $L_1$ can be relabeled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ where $L_A$ is the authority.
The authority is a label $L_A$ of the form $\{p: \ \}$ for every \principal{} in the current authority.

$L_1$ can be relabelled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ is true.
\begin{definition}
    $$\frac{L_1 \sqsubseteq L_2 \sqcup L_A}{L_1 \text{ may be declassified to } L_2}$$
\end{definition}

\paragraph{Relabeling by Restriction}
When a \xvalue{} is read from a variable it has the same label as the variable.
When a \xvalue{} is stored in a variable the label of the \xvalue{} is forgotten.
When doing assignment, e.g. if we have $a = 4$, and we want to assign the value of another variable, $b$, to $a$.
First we read the \xvalue{} from $a$, this means the \xvalue{} of $a$, $4$, has the same label as $a$.
Now we assign the copied \xvalue{}, $4$, to $b$, this means the \xvalue{} gets the label of the variable $b$, replacing its own label.
This means that the label that the \xvalue{} got from $a$ is forgotten.
This process is what we call relabeling, and more specifically this kind of relabeling is called restriction.

To avoid leakage the label of the variable must be at least as restrictive.
For instance if we have two labels, $L_1$ and $L_2$, $L_1 \sqsubseteq L_2$ means that $L_2$ is more restricted than $L_1$.

So a restriction is when the new label guarantees to enforce all of the policies from the old label.
If we have policy $J$ in $L_1$ it is guranteed by another policy $K$ if they have the same owner and $r(K)$ is a subset of $r(J)$.
\begin{definition}
$$\frac{\forall (J \ \in \ L_1) \exists (K \ \in \ L_2)(o(K) = o(J) \ \wedge \ r(K) \subseteq r(J))}{L_1 \sqsubseteq L_2}$$
\end{definition}

\subsection{Acts-for relation}
A \principal{} in DLM can represent a user in the system, a group of users or roles.
As labels on slots are immutable, in order to have more dynamic security policies we have that \principals{} are able to \textit{act for} other \principals{}.
This means that a given \principal{} in effect has every right that the \principal{} that it acts for has.

This is also called a \principal{} hierarchy.
Formally we use the $\succeq$-operator when representing acts for.\footnote{$\succeq$ is reflexive and transitive and not anti-symmetric.}
For instance $x \succeq y$ means $x$ acts for $y$.
A \principal{} hierarchy $P$ is a set of ordered pairs of \principals{}.
So if we have $P \vdash x \succeq y$ it means that $(x,y) \in P$.

Given the acts-for relation and \principals{} $Amy$ and $Bob$, $Amy \succeq Bob$ means that Amy \textit{acts for} Bob.
Any security policies that apply to Bob will in effect also apply to Amy.
Groups or roles are no different than any other principal -- given a new \principal{} $Admin$ we can have that $Amy \succeq Admin$, signifying that Amy is an administrator and therefore can act for on behalf of the administrator group.

\subsection{Limitations}
The rule of restriction is too strict as it is only possible to remove readers and add policies and therefore prevents valid relabelings.
These three possible valid relabelings which are not possible at the moment show why the rule of restriction is too strict:

\begin{itemize}
\item \textbf{Adding readers}
If we have reader $r' \succeq r$ and reader $r$ is a reader of some owner.
It should be possible to add reader $'r$ as a reader because $r' \succeq r$.

\item \textbf{Replacing owners}
If we have owner $o' \succeq o$ then it should be possible to replace $o$ with $o'$ because $o' \succeq o$.

\item \textbf{Self-authorisation}
Given an owner of a policy it should be possible to add any readers which act for the owner.
As mentioned earlier the owner is implicitly a reader of its own policy.
Therefore the readers that act for the owner should be allowed too.

As the owner of the policy always can be added explicitly, self-authorisation does not add anything significant to the label model.
\end{itemize}


\paragraph{Extending the model}
We need to extend the model in order to be able to add readers and replace owners.
To be able to do this we introduce an interpretation function: $\textbf{X}$, which is used when interpreting a label.
This function considers the \principal{} hierarchy and takes a label as an argument.

Given a label as a set of flows we can see that a set of flows has to follow two constraints.
The reader and owner constraint needs to be followed if a set of flow should make sense.
The two constraints are defined below.

\begin{definition}
  Given a label as a set of flows, the set of flows has to follow the \textbf{reader constraint}.
  If we have $(o,r)$ and $r' \succeq r$ then $(o,r')$ must also be in the set of flows.
  Formally ($\rightarrow$ used for implication):
  \begin{center}
    $r' \succeq r \ \wedge \ (o,r) \in \textbf{X}L \rightarrow (o,r') \in \textbf{X}L$
  \end{center}
\end{definition}

\begin{definition}
  Given a label as a set of flows, the set of flows has to follow the \textbf{owner constraint}.
  If we have $(o,r)$ and $o' \succeq o$ and relabel to $(o',r)$, so a owner gets replaced by an owner that acts for it.
  Formally ($\rightarrow$ used for implication):
  \begin{center}
    $o' \succeq o \ \wedge \ (o',r) \notin \textbf{X}L \rightarrow (o,r) \notin \textbf{X}L$
  \end{center}
\end{definition}


\subsection{Label functions}
We now want to construct the label interpretation function $\textbf{X}$.
To be able to do that we define two functions that establish the reader and owner constraint.

\paragraph{Reader function}
The reader function $\textbf{R}$ will now be defined.
This function has to add the following readers to the set of readers in a policy.
\begin{itemize}
\item Readers that are implicitly allowed by the reader constraint
\item The owner
\item Any \principals{} that can act for the owner
\end{itemize}
We can now give a formal definition.

\begin{definition}
  The reader function $\textbf{R}$ takes a policy $I$ as input, written $\textbf{R}I$.
  It outputs a policy with the same owner where the readers are expanded.
  \begin{center}
    $\textbf{R} = (\textbf{o}I : \{r' | r' \succeq \textbf{o}I \wedge \exists(r \in \textbf{r}I) r' \succeq r \})$
  \end{center}
  This can be shortened by introducing $\textbf{r}^+$ that takes a policy as input and outputs a set of readers containing the set of readers of the policy and its owner.\bruno{Kringlet for at sige noget meget simpelt -.-}
  \begin{center}
    $\textbf{r}^+I = \textbf{r}I \cup \{\textbf{o}I\}$
  \end{center}
  \begin{center}
    $\textbf{R} = (\textbf{o}I : \{r | \exists(r' \in \textbf{r}^+I) r \succeq r' \})$
  \end{center}
  $\textbf{R}$ can also take a label as input because that is the same as applying $\textbf{R}$ to all policies in the label.
\end{definition}

Below is an example where $\textbf{R}$ takes a label containing two policies as input.
\begin{example}{Reader function}\label{example_reader_function}
  Given a label $L_1 = \{A:B; C:B,D\}$ where the principal hierarchy only contains $C \succeq A$.
  \begin{center}
    $\textbf{R}L_1 = \{A:B,A,C; C:B,D,C\}$
  \end{center}
\end{example}

\paragraph{Owner function}
The owner function $\textbf{O}$ will now be defined.
The function takes a label as input and outputs a set of flows that are restricted in regard to the \principal{} hierarchy.
$\textbf{O}$ removes flows that do not obey the owner constraint.
$\textbf{O}$ also adds flows for \principals{} when no owner of any policy in the label acts for it.
We can now give a formal definition.
\begin{definition}
  Given label $L$ the owner function $\textbf{O}$ takes it as input and outputs a set of flows.
  \begin{center}
    $\textbf{O}L = \{(o,r) | \forall (I \in L) \textbf{o}I \succeq r \in \textbf{r}I\}$
  \end{center}
\end{definition}

\begin{example}{Owner function}\label{example_owner_function}
  Given the label $\textbf{R}L_1$ from \cref{example_reader_function}:
  \begin{center}
    $\textbf{R}L_1 = \{A:B,A,C; C:B,D,C\}$
  \end{center}
  Now we take $\textbf{R}L_1$ as input to the owner function $\textbf{O}$ we get the following result represented as a label:
  \begin{center}
    $\textbf{OR}L_1 = \{A:B,C; C:B,D,C\}$
  \end{center}
  We can see that the $A$ is eliminated in the first policy.
  This i because the $C$ does not allow $A$ as a reader and $C$ acts for $A$. 
\end{example}

\paragraph{Interpretation function}
We can now finally define $\textbf{X}$.
As mentioned earlier we want $\textbf{X}$ to be able to interpret a label taking the principal hierarchy into account.
If we combine $\textbf{R}$ and $\textbf{O}$ we get the above.
\begin{definition}
  Combining $\textbf{R}$ and $\textbf{O}$ we get $\textbf{X}$.
  \begin{center}
    $\textbf{X}L = \textbf{OR}L$
  \end{center}
\end{definition}
$\textbf{X}L$ obeys the reader and owner constraint as they are preserved by $\textbf{R}$ and $\textbf{O}$.
For example of using $\textbf{X}$ sequentially combine \cref{example_reader_function} and \cref{example_owner_function}.


\subsection{Extending the relabeling by restriction rule}




The function \textbf{R} is essentially adds all readers that can be found by looking at the acts for relations.
The \textbf{O} function converts a label into a set of flows and removes the ones that are not allowed.
Definition of the interpretation function $\textbf{X}$:
\begin{definition}
  $\textbf{X}L \ = \ \textbf{OR}L \ = \ \{(o,r)|\forall (I \in L) \textbf{o}I \succeq o \rightarrow [r \succeq \textbf{o}I \vee \exists (r' \in \textbf{r}I) r \succeq r'] \}$
\end{definition}

By using \textbf{X} we can verify a relabeling by applying the following correctness check.
\begin{definition}
  $\frac{\textbf{X}(L_1, P)\subseteq \textbf{X}(L_2,P)}{\text{Relabeling from } L_1 \text{ to } L_2 \text{ is safe in } P }$
\end{definition}
\mikkelin{Jeg synes alle definitionerne i ovenstående er for lidt forklarende.
Det er for lidt information man får når der kun er en ligning/et udtryk. \#69}

\subsection{Channels}
The model contains two channels, an input and an output channel.
Information can be leaked through these channels, therefore they have a label associated to them.
When a \xvalue{} enters the system through an input channel, the \xvalue{} gets the label of the input channel.
If a \xvalue{} is written to an output channel it can only be done if the label of the output channel is at least as restrictive as the label of the \xvalue{}.
\bruno{Example?}
\mikkelin{Jeg synes vi skal lave et eksempel (fx noget pseudo kode) og så bruge det fra start til slut.}

\subsection{Static checking}
\bruno{Udvider correctnes check'et så det kan bruges til statisk check}
