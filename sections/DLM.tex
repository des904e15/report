\section{Decentralized Label Model}\bruno{insert phd dlm source}
\bruno{Skal vi holde os til en term: value, data, information. De bruger det i flæng i litteraturen?}
\newcommand{\xvalue}{value}
\newcommand{\xvalues}{values}

\paragraph{Acts for relation}
The acts for relation, $\rightarrow$, can be used to model groups and roles.
To model two \principals{}, Amy and Bob, to act for a group of programmers: $Amy \rightarrow programmers$ and $Bob \rightarrow programmers$.
Or if Amy has different roles: $Amy \rightarrow Amy\_programmer$ and $Amy \rightarrow Amy\_admin$.

This is also called a \principal{} hierarchy.
Formually we use the $\succeq$-operator when representing acts for.\footnote{$\succeq$ is reflexive and transitive and not anti-symmetric}
For instance $x \succeq y$ means $x$ acts for $y$.
A \principal{} hierarchy $P$ is a set of ordered pairs of \principals{}.
So if we have $P \vdash x \succeq y$ it means that $(x,y) \in P$.

\paragraph{Value}
A \xvalue{} is a piece of data in a program, for instance an integer.

\paragraph{Privacy policy}
A privacy policy is represented as an owner of some \xvalue{} and a set of readers.
The syntax is: <owner>: <readers>.
The owner is the \principal{} who owns the \xvalue{} that was used for constructing the \xvalue{}.
The readers are the \principals{} allowed by the owner.
The owner is implicitly allowed to read his own data.
If we want a \principal{} $p$ that should not allow any readers we use the following syntax: $p: \ $.

\paragraph{Labels}\bruno{Add how there is a flow 'inside' a label from owners to readers and add reader constraints and owner constraint rules}
A \xvalue{} is associated with a label and is a set of privacy policies.
When the \xvalue{} flows through the system, all the policies need to be obeyed.
The policies are intersected, so we have one set of owners and readers.
Labeled \xvalues{} are only released by the consensus of all the owners and can only be read by the readers.
If one or several privacy policies are added it restricts the \xvalue{}.
A label with an empty set of readers means that all readers are allowed.
If a \principal is not among the owners of a label, it is the same as if it was added as a privacy policy with all posible readers.
When we have three owners: $o_1, o_2, o_3$ and three readers: $r_1, r_2, r_3$ and the following labels:
$L_1 = {o_1: r_1,r_2, o_2: r_1, r_3}$ $L_2 = {o_1: r_1,r_2, o_2: r_1, r_3, o_3: r_1, r_2, r_3}$ we have that: $L_1 = L_2$ because when $o_3$ is not among the owners in $L_1$ it is the same as if it was there with all possible readers as in $L_2$.


When a label interprets it's privacy policies it understands it as a set of flows.
A flow $(o,r)$ is a flow of information from owner $o$ to reader $r$.
If a label contains this flow it means that the owner allows the reader to read the \xvalue{}.
If we have three \principals{} $A,\ B,\ C$ and a label: $\{A: B; C: \ \}$.
This means that $A$ allows its \xvalue{} to be read by $B$, $B$ allows every reader and $C$ allows no readers.
Therefore the flow set of the label is: $\{(A,B), (B,A), (B,B), (B,C) \}$.





If a label contains no policies it is written as an empty set.
A label can contain one or more privacy policies for the same \principal{}.
These are enforced just as other policies.
\bruno{You want more example??}


Some further notation:
We have policy $K$ and label $L$.
\begin{itemize}
\item $K \in L$, policy $K$ is a part of label $L$
\item $o(K)$ or $oK$, the owner of policy $K$
\item $r(K)$ or $rK$, the set of readers of policy $K$
\end{itemize}
\bruno{Kommer lige an på hvad vi ender med at bruge}

\subsection{Rules}
This section contains the rules that need to be followed to avoid information leakage.

\paragraph{Relabeling by Restriction}
This rule is for when one is doing an assignment of a \xvalue{} into a variable.
When a \xvalue{} is read its label is relabelled to the variable and forgotten.
To avoid leakage the label of the variable must be at least as restrictive.
For instance if we have two labels, $L_1$ and $L_2$, $L_1 \sqsubseteq L_2$ means that $L_2$ is more restricted than $L_1$.

So a restriction is when the new label guarantees to enforce all of the policies form the old label.
If we have policy $J$ in $L_1$ it is guranteed by another policy $K$ if they have the same owner and $rK$ is a subset of $rJ$.
\begin{center}
$\frac{\forall (J \ \in \ L_1) \exists (K \ \in \ L_2)(oK = oJ \ \wedge \ rK \subseteq rJ)}{L_1 \sqsubseteq L_2}$
\end{center}
\bruno{definition of the relabeling rule - skal den være her?}

\paragraph{Label join}
When computing two \xvalues{} a value is derived.
The derived \xvalues{} label must reflect its sources, so it has to be at least as restrictive.
To ensure this the two labels are joined, this gives us the following join rule:
\begin{center}
  $L_1 \sqcup L_2 = L_1 \cup L_2$
\end{center}

\paragraph{Relabeling by declassification}
The owners of the labels control their data, but sometimes the policies are overly restrictive and one wants to relax them.
This leads up to the next rule, the declassificaiton rule, which provides a way to declassify a label in the right setting.

The authority is a set of \principals{} which is the authority of the process of declassification.
If a process has the authority of a \principal{} the actions of the process are permitted.
This means that if a \principal{} is in the authority set this can be declassified.

A label $L_1$ can be relabeled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ where $L_A$ is the authority.
The authority is a label $L_A$ of the form ${p: \ }$ for every \principal{} in the current authority.

\begin{center}
  $\frac{L_A = \sqcup_{(p \  \mbox{in current authority})}\{p: \ \}}{L_1 \ \mbox{may be declassified to} \ L_2}$
\end{center}
\bruno{math mode font size!?}

\subsection{Channels}
The model contains two channels, an input and an output channel.
Information can be leaked through these channels, therefore they have a label associated to them.
When a \xvalue{} enters the sytem through an input channel, the \xvalue{} gets the label of the input channel.
If a \xvalue{} is written to an output channel it can only be done if the label of the output channel is more or as restrictive as the label of the \xvalue{}.
\bruno{Example?}

\subsection{Static checking}

\subsection{Limitations}
Timing attacks on timing channels such as cache miss timing.
