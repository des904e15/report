\section{Decentralized Label Model}
\bruno{Skal vi holde os til en term: value, data, information. De bruger det i flæng i litteraturen?}
\newcommand{\xvalue}{value}
\newcommand{\xvalues}{values}

\subsection{Definition of terms}
This section defines and explains some of the terms used to explain the DLM.

\paragraph{Acts for relation}
The acts for relation, $\rightarrow$, can be used to model groups and roles.
To model two \principals{}, Amy and Bob, to act for a group of programmers: $Amy \rightarrow programmers$ and $Bob \rightarrow programmers$.
Or if Amy has different roles: $Amy \rightarrow Amy\_programmer$ and $Amy \rightarrow Amy\_admin$.

This is also called a \principal{} hierarchy.
Formually we use the $\succeq$-operator when representing acts for.\footnote{$\succeq$ is reflexive and transitive and not anti-symmetric}
For instance $x \succeq y$ means $x$ acts for $y$.
A \principal{} hierarchy $P$ is a set of ordered pairs of \principals{}.
So if we have $P \vdash x \succeq y$ it means that $(x,y) \in P$.

\paragraph{Value}
A \xvalue{} is a piece of data in a program, for instance an integer.

\paragraph{Privacy policy}
A privacy policy is represented as an owner of some \xvalue{} and a set of readers.
The syntax is: <owner>: <readers>.
The owner is the \principal{} who owns the \xvalue{} that was used for constructing the \xvalue{}.
The readers are the \principals{} allowed by the owner.
The owner is implicitly allowed to read his own data.
If we want a \principal{} $p$ that should not allow any readers we use the following syntax: $p: \ $.

\subsection{Labels}
A \xvalue{} is associated with a label and is a set of privacy policies.
When the \xvalue{} flows through the system, all the policies need to be obeyed.
The policies are intersected, so we have one set of owners and readers.
Labeled \xvalues{} are only released by the consensus of all the owners and can only be read by the readers.
If one or several privacy policies are added it restricts the \xvalue{}.
A label with an empty set of readers means that all readers are allowed.
If a \principal is not among the owners of a label, it is the same as if it was added as a privacy policy with all posible readers.
When we have three owners: $o_1, o_2, o_3$ and three readers: $r_1, r_2, r_3$ and the following labels:
$L_1 = {o_1: r_1,r_2, o_2: r_1, r_3}$ $L_2 = {o_1: r_1,r_2, o_2: r_1, r_3, o_3: r_1, r_2, r_3}$ we have that: $L_1 = L_2$ because when $o_3$ is not among the owners in $L_1$ it is the same as if it was there with all possible readers as in $L_2$.


When a label interprets it's privacy policies it understands it as a set of flows.
A flow $(o,r)$ is a flow of information from owner $o$ to reader $r$.
If a label contains this flow it means that the owner allows the reader to read the \xvalue{}.
If we have three \principals{} $A,\ B,\ C$ and a label: $\{A: B; C: \ \}$.
This means that $A$ allows its \xvalue{} to be read by $B$, $B$ allows every reader and $C$ allows no readers.
Therefore the flow set of the label is: $\{(A,B), (B,A), (B,B), (B,C) \}$.


If a label contains no policies it is written as an empty set.
A label can contain one or more privacy policies for the same \principal{}.
These are enforced just as other policies.

Some further notation:
We have policy $K$ and label $L$.
\begin{itemize}
\item $K \in L$, policy $K$ is a part of label $L$
\item $o(K)$ or $oK$, the owner of policy $K$
\item $r(K)$ or $rK$, the set of readers of policy $K$
\end{itemize}
\bruno{Kommer lige an på hvad vi ender med at bruge}

\subsection{Rules}
This section contains the rules that need to be followed to avoid information leakage.

\paragraph{Label join}
When computing two \xvalues{} a value is derived.
The derived \xvalues{} label must reflect its sources, so it has to be at least as restrictive.
To ensure this the two labels are joined, this gives us the following join rule:
\begin{center}
  $L_1 \sqcup L_2 = L_1 \cup L_2$
\end{center}

\paragraph{Relabeling by declassification}
The owners of the labels control their data, but sometimes the policies are overly restrictive and one wants to relax them.
This leads up to the next rule, the declassificaiton rule, which provides a way to declassify a label in the right setting.

The authority is a set of \principals{} which is the authority of the process of declassification.
If a process has the authority of a \principal{} the actions of the process are permitted.
This means that if a \principal{} is in the authority set this can be declassified.

A label $L_1$ can be relabeled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ where $L_A$ is the authority.
The authority is a label $L_A$ of the form ${p: \ }$ for every \principal{} in the current authority.

\begin{center}
  $\frac{L_A = \sqcup_{(p \  \mbox{in current authority})}\{p: \ \}}{L_1 \ \mbox{may be declassified to} \ L_2}$
\end{center}
\bruno{math mode font size!?}

\paragraph{Relabeling by Restriction}
This rule is for when one is doing an assignment of a \xvalue{} into a variable.
When a \xvalue{} is read its label is relabelled to the variable and forgotten.
To avoid leakage the label of the variable must be at least as restrictive.
For instance if we have two labels, $L_1$ and $L_2$, $L_1 \sqsubseteq L_2$ means that $L_2$ is more restricted than $L_1$.

So a restriction is when the new label guarantees to enforce all of the policies form the old label.
If we have policy $J$ in $L_1$ it is guranteed by another policy $K$ if they have the same owner and $rK$ is a subset of $rJ$.
\begin{center}
$\frac{\forall (J \ \in \ L_1) \exists (K \ \in \ L_2)(oK = oJ \ \wedge \ rK \subseteq rJ)}{L_1 \sqsubseteq L_2}$
\end{center}
\bruno{definition of the relabeling rule - skal den være her?}

\subsection{Limitations}
The rule for declassification is too strict as it is only possible to remove readers and add policies and therefore prevents valid relabelings.
There are three possible valid relabelings which are not possible at the moment:
\begin{itemize}
\item Adding readers - if we have $r' \succeq r$ and $r$ is a reader of some owner, $'r$ should be too.
\item Replacing owners - if we have $o' \succeq o$ then it should be possible to replace $o$ with $o'$.
\item Self-authorization - every \principal{} that acts for an owner of a policy should be possible to add as a reader.
\end{itemize}

\subsubsection{Extending the relabeling by restriciton rule}
We need to extend the rule in order to be able to do the things discussed above.

To take the \principal{} hierarchy into account when interpreting a label an interpretation function $\textbf{X}$ is introduced.
For now $\textbf{X}$ takes a label as argument and the set of \principals{} $P$ as an implicit argument.
Informally this function makes sure that if a reader or owner that acts for some \principal{} $p$ - that $p$ is included in the label interpretation.


The set of flows for a label need to satisfy two constraints for the given principal hierarchy.
One for readers and one for owners.
The following is the shows the reader constraint:
If we have $(o,r)$ and $r' \succeq r$ then $o,r'$ must also be in the set of flows.
Formally($\rightarrow$ used for implication):
\begin{center}
  $r' \succeq r \ \wedge \ (o,r) \in \textbf{X}L \rightarrow (o,r') \in \textbf{X}L$
\end{center}
And the owner constraint:
If we have $(o,r)$ and $o' \succeq o$ and relabel to $(o',r)$, so a owner gets replaced by an owner that acts for it.
\begin{center}
  $o' \succeq o \ \wedge \ (o',r) \notin \textbf{X}L \rightarrow (o,r) \notin \textbf{X}L$
\end{center}

The function \textbf{R} is essentially adds all readers that can be found by looking at the acts for relations.
The \textbf{O} function converts a label into a set of flows and removes the once that are not allowed.
Definition of the interpretation function $\textbf{X}$:
\begin{definition}
  $\textbf{X}L \ = \ \textbf{OR}L \ = \ \{(o,r)|\forall (I \in L) \textbf{o}I \succeq o \rightarrow [r \succeq \textbf{o}I \vee \exists (r' \in \textbf{r}I) r \succeq r'] \}$
\end{definition}

By using \textbf{X} we can verify a relabeling by applying the following correctness check.
\begin{definition}
  $\frac{\textbf{X}(L_1, P)\subseteq \textbf{X}(L_2,P)}{\mbox{Relabeling from} \ L_1 \ \mbox{to} \ L_2 \ \mbox{is safe in} \ P }$
\end{definition}

\subsection{Channels}
The model contains two channels, an input and an output channel.
Information can be leaked through these channels, therefore they have a label associated to them.
When a \xvalue{} enters the sytem through an input channel, the \xvalue{} gets the label of the input channel.
If a \xvalue{} is written to an output channel it can only be done if the label of the output channel is more or as restrictive as the label of the \xvalue{}.
\bruno{Example?}

\subsection{Static checking}
\bruno{FUCK}
