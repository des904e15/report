\section{Decentralized Label Model}
\bruno{Skal vi holde os til en term: value, data, information. De bruger det i flæng i litteraturen?}
\newcommand{\xvalue}{value}
\newcommand{\xvalues}{values}

\paragraph{Acts for relation}
The acts for relation, $\rightarrow$, can be used to model groups and roles.
To model two \principals{}, Amy and Bob, to act for a group of programmers: $Amy \rightarrow programmers$ and $Bob \rightarrow programmers$.
Or if Amy has different roles: $Amy \rightarrow Amy\_programmer$ and $Amy \rightarrow Amy\_admin$.

\paragraph{Value}
A \xvalue{} is a piece of data in a program, for instance an integer.

\paragraph{Privacy policy}
A privacy policy is represented as an owner of some \xvalue{} and a set of readers.
The syntax is: <owner>: <readers>.
The owner is the \principal{} who owns the \xvalue{} that was used for constructing the \xvalue{}.
The readers are the \principals{} allowed by the owner.
The owner is implicitly allowed to read his own data.

\paragraph{Labels}
A \xvalue{} is associated with a label and is a set of privacy policies.
When the \xvalue{} flows through the system, all the policies need to be obeyed.
The policies are intersected, so we have one set of owners and readers.
Labeled \xvalues{} are only released by the consensus of all the owners and can only be read by the readers.
If one or several privacy policies are added it restricts the \xvalue{}.
A label with an empty set of readers means that all readers are allowed.
If a \principal is not among the owners of a label, it is the same as if it was added as a privacy policy with all posible readers.
When we have three owners: $o_1, o_2, o_3$ and three readers: $r_1, r_2, r_3$ and the following labels:
$L_1 = {o_1: r_1,r_2, o_2: r_1, r_3}$ $L_2 = {o_1: r_1,r_2, o_2: r_1, r_3, o_3: r_1, r_2, r_3}$ we have that: $L_1 = L_2$ because when $o_3$ is not among the owners in $L_1$ it is the same as if it was there with all possible readers as in $L_2$.


If a label contains no policies it is written as an empty set.
A label can contain one or more privacy policies for th same \principal{}.
These are enforced just as other policies.
\bruno{You want more example??}


Some further notation:
We have policy $K$ and label $L$.
\begin{itemize}
\item $K \in L$, policy $K$ is a part of label $L$
\item $o(K)$ or $oK$, the owner of policy $K$
\item $r(K)$ or $rK$, the set of readers of policy $K$
\end{itemize}
\bruno{Kommer lige an på hvad vi ender med at bruge}

\subsection{Rules}
This section contains the rules that need to be followed to avoid information leakage.

\paragraph{Relabeling by Restriction}
This rule is for when one is doing an assignment of a \xvalue{} into a variable.
When a \xvalue{} is read its label is relabelled to the variable and forgotten.
To avoid leakage the label of the variable must be at least as restrictive.
For instance if we have two labels, $L_1$ and $L_2$, $L_1 \sqsubseteq L_2$ means that $L_2$ is more restricted than $L_1$.

So a restriction is when the new label guarantees to enforce all of the policies form the old label.
If we have policy $J$ in $L_1$ it is guranteed by another policy $K$ if they have the same owner and $rK$ is a subset of $rJ$.
\begin{center}
$\frac{\forall (J \ \in \ L_1) \exists (K \ \in \ L_2)(oK = oJ \ \wedge \ rK \subseteq rJ)}{L_1 \sqsubseteq L_2}$
\end{center}
\bruno{definition of the relabeling rule - skal den være her?}

\paragraph{Label join}
When computing two \xvalues a value is derived.
The derived \xvalues label must reflect its sources, so it has to be at least as restrictive.

\subsection{Limitations}
Timing attacks on timing channels such as cache miss timing.
