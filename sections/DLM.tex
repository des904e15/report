\section{Decentralized Label Model}
\bruno{Skal vi holde os til en term: value, data, information. De bruger det i flæng i litteraturen?}
\stefan{jeg synes vi skal holde os til én term}
\mikkelin{Jeg synes de forskellige termer kan dække over forskellige ting og giver mening i forskellig kontekst.
Så nej, jeg synes ikke vi skal holde os til en af dem.}
\bruno{Er det her denretning vi vil i? Hvis ja - så vil jeg godt tilføje nogle figurer til de små eksempler.}
\newcommand{\xvalue}{value}
\newcommand{\xvalues}{values}
This section describes the Decentralized Label Model(DLM) both formally and informally with small examples.
\stefan{der mangler noget blødere introduktion der forklarer hvad DLM er og hvad det skal bruges til}
\mikkelin{Enig - det bør umiddelbart være den uformelle beskrivelse der kommer her.
Jeg har i øvrigt svært ved at finde den uformelle beskrivelse i teksten.}

\subsection{Definition of terms}
\mikkelin{Jeg synes det her afsnit er lidt underligt.
Hvorfor er acts for og privacy policy kun \emph{terms}?
Burde de ikke bare have deres egen subsection?}
This section defines and explains some of the terms used to explain the DLM.
\mikkelin{Samme kommentar som Stefans ovenfor.
Det er svært at følge teksten når vi som det første hopper direkte til \textbf{acts for} uden nogen motivation for hvorfor eller har en overordnet forståelse af modellen.}

\paragraph{Acts for relation}
The acts for relation, $\rightarrow$, can be used to model groups and roles.
To model two \principals{}, Amy and Bob, that act for a group of programmers: $Amy \rightarrow programmers$ and $Bob \rightarrow programmers$.
Or if Amy has different roles: $Amy \rightarrow Amy\_programmer$ and $Amy \rightarrow Amy\_admin$.
\mikkel{Som jeg læser det er der to forskellige eksempler her.
Men vi mangler en beskrivelse af hvad formålet med acts for er og hvad det betyder i DLM.}

\stefan{brug $\succeq$ i stedet for $\rightarrow$ }

This is also called a \principal{} hierarchy.
Formally we use the $\succeq$-operator when representing acts for.\footnote{$\succeq$ is reflexive and transitive and not anti-symmetric}
For instance $x \succeq y$ means $x$ acts for $y$.
A \principal{} hierarchy $P$ is a set of ordered pairs of \principals{}.
So if we have $P \vdash x \succeq y$ it means that $(x,y) \in P$.

\paragraph{Value}
A \xvalue{} is a piece of data in a program, for instance an integer.
\mikkel{Jeg ville slette det her, men jeg vil gerne lige vende det med gruppen. Er det nødvendigt at forklare hvad ``value'' betyder?}

\paragraph{Privacy policy}
A privacy policy is represented as an owner of some \xvalue{} and a set of readers.
The syntax is: <owner>: <readers>.
The owner is the \principal{} who owns the \xvalue{} that was used for constructing the \xvalue{}.
The readers are the \principals{} allowed by the owner.
The owner is implicitly allowed to read his own data.
If we want a \principal{} $p$ that should not allow any readers we use the following syntax: $p: <space> $.
\bruno{Synes det var mere klart end $p: \ $.}

\subsection{Labels}\bruno{Måske lidt roddet afsnit?}
A \xvalue{} is associated with a label.
The label is a set of privacy policies.
When the \xvalue{} flows through the system, all the policies need to be obeyed.
That means that the effective set of \principals{} able to read the \xvalue{} is the intersection of all policies in a label.


Labeled \xvalues{} are only released by the consensus of all the owners and can only be read by the readers.
If one or several privacy policies are added it to a label restricts the \xvalue{}.
A label with no policies  means that all readers are allowed.

If a \principal{} is not among the owners of a label, it is the same as if it was added as a privacy policy with all posible readers, implicitly indicating that this owner has no preference of who reads the \xvalue{}.


For example when we have three owners: $o_1, o_2, o_3$ and three readers: $r_1, r_2, r_3$ and the following labels:
$L_1 = \{o_1: r_1,r_2; o_2: r_2, r_3\}$
$L_2 = \{o_1: r_1,r_2; o_2: r_2, r_3; o_3: r_1, r_2, r_3\}$
we have that: $L_1 = L_2$ because when $o_3$ is not among the owners in $L_1$ it is the same as if it was there with all possible readers as in $L_2$ - the resulting effective set of readers is the same.

When a label interprets its privacy policies it understands it as a set of flows.
A flow $(o,r)$ is a flow of information from owner $o$ to reader $r$.
If a label contains this flow it means that the owner allows the reader to read the \xvalue{}.
If we have three \principals{} $A,\ B,\ C$ and a label: $\{A: B; \ C: <space> \}$.
This means that $A$ allows its \xvalue{} to be read by $B$, $B$ allows every reader and $C$ allows no readers.
Therefore the flow set of the label is: $\{(A,B), (B,A), (B,B), (B,C) \}$.
\stefan{jeg savner en forklaring af hvad vi skal bruges flows til, hvad betyder flow mængden?}

If a label contains no policies it is written as an empty set.
A label can contain one or more privacy policies for the same \principal{}.
These are enforced just as other policies.

Some further notation:
We have policy $K$ and label $L$.
\begin{itemize}
\item $K \in L$, policy $K$ is a part of label $L$
\item $\textbf{o}(K)$ or $\textbf{o}K$, the owner of policy $K$
\item $\textbf{r}(K)$ or $\textbf{r}K$, the set of readers of policy $K$
\end{itemize}
\bruno{Kommer lige an på hvad vi ender med at bruge:  $\textbf{o}(K)$ or $\textbf{o}K$}
\stefan{synes bedst om dem med paranteser, det andet ser underligt ud}

\subsection{Rules}
This section contains the rules that need to be followed when manipulating labels to avoid information leakage.

\paragraph{Label join}
When computing two \xvalues{} a \xvalue{} is derived.
The derived \xvalues{} label must reflect its sources, so it has to be at least as restrictive.
To ensure this the two labels are joined by calculating the union of the two labels, this gives us the following join rule:
\begin{definition}
  $L_1 \sqcup L_2 = L_1 \cup L_2$
\end{definition}


\paragraph{Relabeling by declassification}
The owners of the labels control their data, but sometimes the policies are overly restrictive and one wants to relax them.
This leads up to the next rule, the declassificaiton rule, which provides a way to declassify a label in the right setting.

The authority is a set of \principals{} which is the authority of the process of declassification.
If a process has the authority of a \principal{}, the actions of the process are permitted.
This means that if a \principal{} is in the authority set this can be declassified.

\stefan{der mangler forklaring af hvad  $\sqsubseteq$ er }
A label $L_1$ can be relabeled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ where $L_A$ is the authority.
The authority is a label $L_A$ of the form $\{p: \ \}$ for every \principal{} in the current authority.
Given:
\begin{center}
  $L_A = \bigsqcup_{(p \text{ in current authority})}\{p: <space> \}$
\end{center}
$L_1$ can be relabelled to $L_2$ if $L_1 \sqsubseteq L_2 \sqcup L_A$ is true.
\begin{definition}
    $\frac{L_1 \sqsubseteq L_2 \sqcup L_A}{L_1 \text{ may be declassified to } L_2}$
\end{definition}

\paragraph{Relabeling by Restriction}
This rule is for when one is doing an assignment of a \xvalue{} into a variable.
When a \xvalue{} is read its label is relabelled to the variable and forgotten.
To avoid leakage the label of the variable must be at least as restrictive.
For instance if we have two labels, $L_1$ and $L_2$, $L_1 \sqsubseteq L_2$ means that $L_2$ is more restricted than $L_1$.

So a restriction is when the new label guarantees to enforce all of the policies from the old label.
If we have policy $J$ in $L_1$ it is guranteed by another policy $K$ if they have the same owner and $rK$ is a subset of $rJ$.
\begin{definition}
$\frac{\forall (J \ \in \ L_1) \exists (K \ \in \ L_2)(oK = oJ \ \wedge \ rK \subseteq rJ)}{L_1 \sqsubseteq L_2}$
\end{definition}
\bruno{definition of the relabeling rule - skal den være her?}

\subsection{Limitations}
The rule of restriction is too strict as it is only possible to remove readers and add policies \stefan{hvorfor er dette tilfældet?} and therefore prevents valid relabelings.
There are three possible valid relabelings which are not possible at the moment:
\begin{itemize}
\item Adding readers - if we have $r' \succeq r$ and $r$ is a reader of some owner, $'r$ should be too.
\item Replacing owners - if we have $o' \succeq o$ then it should be possible to replace $o$ with $o'$.
\item Self-authorization - every \principal{} that acts for an owner of a policy should be possible to add as a reader.
\end{itemize}

\subsubsection{Extending the relabeling by restriciton rule}
We need to extend the rule in order to be able to do the things discussed above.

To take the \principal{} hierarchy into account when interpreting a label an interpretation function $\textbf{X}$ is introduced.
For now $\textbf{X}$ takes a label as argument and the set of \principals{} $P$ as an implicit argument.
Informally this function makes sure that if a reader or owner that acts for some \principal{} $p$ - that $p$ is included in the label interpretation.


The set of flows for a label need to satisfy two constraints for the given principal hierarchy.
One for readers and one for owners.
The following is the shows the reader constraint:
If we have $(o,r)$ and $r' \succeq r$ then $(o,r)'$ must also be in the set of flows.
Formally ($\rightarrow$ used for implication):
\begin{center}
  $r' \succeq r \ \wedge \ (o,r) \in \textbf{X}L \rightarrow (o,r') \in \textbf{X}L$
\end{center}
And the owner constraint:
If we have $(o,r)$ and $o' \succeq o$ and relabel to $(o',r)$, so a owner gets replaced by an owner that acts for it.
\begin{center}
  $o' \succeq o \ \wedge \ (o',r) \notin \textbf{X}L \rightarrow (o,r) \notin \textbf{X}L$
\end{center}

The function \textbf{R} is essentially adds all readers that can be found by looking at the acts for relations.
The \textbf{O} function converts a label into a set of flows and removes the ones that are not allowed.
Definition of the interpretation function $\textbf{X}$:
\begin{definition}
  $\textbf{X}L \ = \ \textbf{OR}L \ = \ \{(o,r)|\forall (I \in L) \textbf{o}I \succeq o \rightarrow [r \succeq \textbf{o}I \vee \exists (r' \in \textbf{r}I) r \succeq r'] \}$
\end{definition}

By using \textbf{X} we can verify a relabeling by applying the following correctness check.
\begin{definition}
  $\frac{\textbf{X}(L_1, P)\subseteq \textbf{X}(L_2,P)}{\text{Relabeling from } L_1 \text{ to } L_2 \text{ is safe in } P }$
\end{definition}

\subsection{Channels}
The model contains two channels, an input and an output channel.
Information can be leaked through these channels, therefore they have a label associated to them.
When a \xvalue{} enters the system through an input channel, the \xvalue{} gets the label of the input channel.
If a \xvalue{} is written to an output channel it can only be done if the label of the output channel is more or as restrictive as the label of the \xvalue{}.
\bruno{Example?}

\subsection{Static checking}
\bruno{Udvider correctnes check'et så det kan bruges til statisk check}
