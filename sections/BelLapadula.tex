%!TEX root=..\master.tex
\section{The Bell-LaPadula Security Policy}

In 1973 Bell and LaPadula devised a mathematical model intended for use in  military and governmental computer systems.
The model formalizes users accessing data and how to handle this in a secure way so confidential information cannot be leaked to a lower classification level.
The following description is based on \citet{lapadula1996secure}.

\subsection{Security}
Before we go into details about how the Bell-LaPadula (BLP) security model is applied to computer systems, we will first discuss some important concepts.

In any system we will have a set of objects $O$ and \subjects{} $S$.
Objects are entities that can somehow be manipulated by \subjects{}.
\Subjects{} are processes or programs in execution that represent a user or a group of users.

\paragraph{Classification and Clearance}
Attached to any object or \ssubject{} will be a classification or clearance respectively.
We denote the set of all classifications/clearances $C = \{C_1, C_2,\dots,C_q\}$ where $\{C_1 > C_2 > \dots > C_q\}$ holds, giving a hierarchical sequence of classifications/clearances.
This means that for any object $o \in O$ with \textit{classification} $C_i \in C$, where $C_i$ is arbitrary, any \ssubject{} $s \in S$ will need a \textit{clearance} $C_j \geq C_i$ in order to access $o$.

\paragraph{Category and Need-to-know}
In addition to classification, objects can belong to one or more categories, which can be seen as security groupings of certain objects.
Similarly, \subjects{} can have one or more need-to-know, which are the security groupings for \subjects{}.
The security categories are a set $K = \{K_1, K_2, \dots, K_r\}$ and unlike classifications/clearances there is no hierarchy of categories.
In order for \ssubject{} $s$ to access an object $o$ with \textit{category} $K_m$ and $K_n$, where $K_m$ and $K_n$ are arbitrary, $s$ must have both \textit{Need-to-know} categories $K_m$ and $K_n$.

\paragraph{Classification and category vectors}
 In the model classifications and categories are stored in vectors.
 Four functions are used for lookup in these vectors.
 $F_1$ performs a lookup in the \ssubject{} classification vector, $F_2$ in the object classification vector, $F_3$ in the \ssubject{} category vector and finally $F_4$ performs a lookup in the object category function.
\stefan{skal vi gøre notationen mere elegant og letlæselig, eller skal vi holde os til rapportens originale weidor?}

\paragraph{Visualization}
This kind of security system can be seen as a \textit{lattice}, see \cref{blp:lattice}.
Each node represents a \emph{security level} which we define as a combination of classification/clearance and a set of categories.

A \ssubject{} with the clearance \emph{Top Secret} is able to access any object with the security level \emph{Top Secret} and all those below (\emph{Secret} and \emph{Unclassified}).
On the contrary, a \ssubject{} with clearance \emph{Unclassified} can only access objects with the security level \emph{Unclassified}.

Similarly, the category(ies) of each node limit what objects a \ssubject{} can access.
If we have a \ssubject{} $s$ with clearance \emph{Top Secret} and category \emph{Crypto}, $s$ will have access to any objects with security level $(Top Secret, \{Crypto\})$ and those below.

\begin{figure}
\centering
\includegraphics[width=\textwidth]{figures/blp_lattice}
\caption{A BLP lattice \cite{security_engineering_ross_anderson}}
\label{blp:lattice}
\end{figure}

\subsection{Access attributes}\label{blp:access_attributes}
The model considers four attributes for access in a complex computer system: \emph{read-only}, \emph{read/write}, \emph{execute} and \emph{append}.
In addition \emph{control access} is used to give attributes to other users.
Formally, the access attributes are defined as a set $A = \{ r, w, e, a, c \}$, each member corresponding to the aforementioned attributes.

\paragraph{Read-only}
This attribute makes it possible to read the object but not alter it.
The classical example is a file that contains information that should not be changed.
Alternatively it could be a list containing the \principals{} in the system with their clearance levels.
A \principal{} of low clearance should be able to read this list but not change it.

\paragraph{Append}
Append describes a pure write operation.
This means that it is possible to append information to the end of a file without being able to extract information about the rest of the file.

This can also be used with a printer which appends information about what is being printed.
By doing this it is sufficient that the classification of a piece of information is matching the classification of the printer in order to prevent unauthorized personnel from reading the information.

\paragraph{Execute}
The execution attribute makes it possible to execute an executable file.
If the \principal{} does not have permission to read from or write to the file he will only be able to execute it.
Similarly the executable file can produce output that is of a higher classification level than the clearance level of the \principal{} executing it.

\paragraph{Read/write}
This attribute signifies that read and write access are both allowed.
This attribute is what is traditionally used when editing text files.

\paragraph{Control access}
The control access attribute models the notion of a \ssubject{} having control over a file.
Having this attribute a \ssubject{} can give the four attributes above to other \subjects{} in the system.

\subsection{Requests and decisions}
In a computer system the \subjects{} are not directly accessing objects in the system, it is processes in the system that act on behalf of the \ssubject{}.
In the following a user requesting access to a file will be written as a \ssubject{} requesting access and the response to this request a decision.

In order to handle access rights we have matrix $M$ of size $|O| \times |S|$ so that we have an entry for each object-\ssubject{} combination -- containing the current access rights.
For any \ssubject{} $S_i$ and object $O_j$ we have at entry $M_{i,j}$ the access rights $S_i$ currently has for $O_j$, of the possible values described in \cref{blp:access_attributes}.

\paragraph{Requests}
There are 4 possible requests that can be made by any \ssubject{}:
\begin{enumerate}
  \item be granted access to an \ssubject{} in a particular mode.
  \item another \ssubject{} should be granted access to an object in a particular mode.
  \item create an object in the system.
  \item delete an object in the system.
\end{enumerate}

In order to carry out the second request, the \ssubject{} needs control access of the object that is being requested access for, as well as the particular mode.
So that for a \ssubject{} $S_i$ requesting read access $r$ for \ssubject{} $S_k$ for object $O_j$, $S_i$ must have both $r$ as well as control access $c$ for $O_j$ itself.
Control access is only given to a certain object when the object is created.
Unlike the other attributes, control access cannot be given by any \ssubject{} to another \ssubject{}.\bruno{Jeg forstår ikke hvorfor man ikke kan/må det?}

When a new object is created, it is initially inactive.
In addition to the 4 requests above, in regards to creating objects, we also have the following 2 additional requests:
\begin{enumerate}
  \item alter classification and category assignment of an unused object.
  \item activate an unused object.
\end{enumerate}

For the 4th request, deletion, the object deemed for deletion is inactivated and all current and future privileges are revoked.

\paragraph{Decisions}
Any request made will be met with a response of values $yes$, $no$, $?$, or $error$.
$yes$ and $no$ responses are given when the request is recognized and a check can be performed, thus giving a response of $yes$ if granted and $no$ if not.
$error$ is given in case the request is recognized, but cannot be given a proper responsed due to more than a single rule can be applied.
$?$ is given in cases where the request was not recognized.
 
\subsection{Preventing security compromise}\label{bellap:properties}
In order to ensure that data cannot be compromised the previous definitions of access attributes and requests can be utilized to formalize properties that ensure that compromise cannot occur.

\subsubsection{Security condition}
The security condition states that a \principal{} with a given clearance level is prevented from having read access to any object which is or can be a source of information with a classification level that is higher than the clearance level of the \principal{}.

Formally this can be expressed as the following:
\begin{definition}
The access matrix contains entries of the form $(s,o,x)$ where $s \in S, o \in O \text{ and } x \in A$.
Such entry satisfies the security condition relative to the classification and need-to-know vectors if and only if

\begin{itemize}
\item x is either the \emph{execute}, \emph{append} or \emph{control} access attribute, or
\item x is the \emph{write} or the \emph{read} attribute and both $f_1(s) \ge f_2(o)$ and $f_3(s) \supseteq f_4(o)$
\end{itemize}

An \emph{access matrix} is secure if every access matrix entry satisfies the security condition.

A system consists of \emph{appearances} which consists of requests and decisions that manipulate the access matrix.

A \emph{system} is a secure system if and only if every appearance of the system is secure.
\end{definition}

Seen in context of the lattice in \cref{blp:lattice}, the security condition can be seen as the disallowance of any \ssubject{} $s$ from reading any objects above its security level (\textbf{no read-up}).

\subsubsection{*-property}
The *-property ensures that given a \principal{} and a set of objects, $o_1$, which he has write or append access to and a set of objects, $o_2$, which he has read or read/write access to.
$o_1$ is the super set of $o_2$ and $o_1$ must exceed or equal $o_2$.
This property ensures that it is impossible to leak information to a lower classification level.

The following definition expresses this formally:
\begin{definition}
Let $b(S:x,y, \dots, z)$ denote the set 

$\{O: o \in O \text{ and } [(s,o,x) \in b, (s,o,y) \in b, \dots, (s,o,z) \in b]\}$.

Here b is the set of access matrix entries of some access matrix.

\paragraph{}
\noindent{} 
A state of an access matrix satisfies the *-property if an only if for each $s \in S$ the following proposition holds.

$[b(s:w,a) \ne \emptyset \text{ and } b(s:r,w) \ne \emptyset] \implies [f_2(o_1) \ge f_2(o_2) \text{ and } f_4(o_1) \supseteq f_4(o_2) \text{ for all } o_1 \in b(s:w,a), o_2 \in b(s:r,w)]$

\paragraph{}
\noindent{} 
A system is satisfying the *-property if and only if every appearance of the system satisfies the *-property.
\end{definition}

When seeing the *-property in the context of \cref{blp:lattice}, the *-property states that it is not allowed for any \ssubject{} $s$ to read any object $o_1$ and write any of this information to an object $o_2$, if $o_2$ is not above, or at the same security level as, $o_1$ (\textbf{no write-down}).
stefan{No read-up og no writedown, er det nogle begreber vi ikke har introduceret? Paranteserne virker som om de refererer til noget}